1. ФИО
Шагал Александра Александровна

2. Какова разница между абстрактным классом и интерфейсом?
Абстрактный класс -- класс, у которого не реализован один из методов. Необходим в случае, когда у нескольких классов будет какое-то общее поведение/общие свойства. Нельзя создать его объект.
Интерфейс описывает методы, которые будут реализованы в классе, который будет имплементировать этот интерфейс.Все методы по умолчанию abstract, а поля static final.
Отличие состоит в том, что у интерфейса не может быть реализован ни один метод, у абстрактного класса могут быть методы; объект абстрактного класса создать нельзя.

3. Как «насильно» вызвать сборку мусора?
JVM (java virtual machine) сама следит за освобождением памяти, выделенной под объекты. Память из-под объектов, на которые не указывает ни одна ссылка высвобождается.в произвольные моменты времени (может долго не происходить, а потом разом очистить всё, что может вызвать подвисание программы).
У класса Object (супер-класс) есть метод finalize(), который вызывается перед непосредственно очищением памяти.
Насильно вызвать сборку мусора можно несколькими способами:
System.gc();
Runtime.getRuntime.gc();
System.runFinalization();
(Не уверена точно в правильности написания функций.)

4. Когда требуется явное приведение классов?
Явное приведение классов, например, требуется при наследовании.
class A {...|} 
class B extends A {...}
A a = new B(); // верно
B b = new A(); // ошибка, необходимо указать компилятору, что мы уверены, что можно сделать такое приведение
B b = (B) new A();
При приведении примитивных типов (сужении)
int x = 10;
long y = 10L;
y = x; // ok, автоматическое приведение
x = y; // ошибка, необходимо явно привести типы.
x = (int) y;

5. Чем конструкторы отличаются от других методов?
Конструктор это метод, вызываемый при создании объекта. Он имеет название, совпадающее с именем класса. Можно переопределять конструкторы. Если в конструкторе произойдёт исключение, объект не создастся. 
Конструктор вызывается только один раз в отличие от методов.

6. Можно ли вызывать конструкторы один из другого, если их в классе несколько?
Да, можно. Этот приём необходим для уменьшения повторения кода.
Пример:
class Rect {
  int _a, _b;
  Rect(int a, int b) {
    this._a = a;
    this._b = b;
  }
  Rect(int a) {
    this(a, a);
  }
}
Т.е. чтобы не повторять код, который уже описан в первом конструкторе, вызовем его из второго.

7. В чем разница между JDK и JRE?
JDK - Java Development Kit 
Набор для разработки и запуска приложений на java. Включает в себя:
- Компилятор javac, который переводит *.java файлы в *.class;
- java, который объединяет *.class файлы и запускает их;
- архиватор jar;
- набор стандартных библиотек *.jar;
- appletviewer для работы с апплетами.
JRE - Java Runtime Environment
Используется только для запуска приложений, включает в себя библиотеки *.jar и java интерпретатор. 

8. Имеет ли значение в каком порядке перехватывать исключения FileNotFoundException и IOExceptipon?
Да, т.к. FileNotFoundException является подклассом класса IOException, т.е. сначала нужно перехватить его, а потом IOException, в противном случае FileNotFoundException не будет выброшен.

9. Могут ли внутренние классы, описанные внутри метода, иметь доступ к локальным переменным этого метода?
Внутренний класс -- класс, который может быть описан внутри класса либо в методе, либо в логическом блоке. Он имеет доступ к полям и методам внешнего класса, может быть унаследован от какого-то класса, может реализовывать интерфейсы, может быть супер-классом для какого-то класса (доступ к нему через внешний класс: Outer.Inner), не может иметь статических полей. Только static final.
Доступ из Inner к полям и методам Outer производится через this: 
Outer.this.field или Outer.this.method();
Поскольку через this локальные переменные метода достать невозможно, предположу, что доступа к ним у него не будет. Всё необходимое можно передать как параметр конструктора, например.

10. Как подкласс может обратиться к методу или конструктору из суперкласса?
Доступ производится через super.method(). конструктор: super();
Например, это может быть необходимо в случае дополнения методов супер-класса какими-то вычислениями в подклассе. Сначала в переопределяемом методе вызовем этот метод супер-класса, а потом дополним нашими вычислениями. Это сокращает код.

11. В чем разница между очередью и стеком?
С точки зрения структур данных разница в идее операций добавления/удаления: LIFO (Last In First Out) у стека и FIFO (FirstIn First Out) у очереди.
Т.е. в стек добавление и удаление производится с "верхушки", а у очереди добавление в один конец, а удаление из другого.

12. Что вам приходит в голову, когда вы слышите о новом поколении (young generation) в Java?


13. Есть два класса: A и B. Класс B должен информировать класс A когда случается некое важное событие. Какой design-pattern вы должны реализовать?


14. Какой модификатор доступа надо указать в классе, чтобы доступ к нему имели только классы из того же пакета?
Модификаторы доступа:
public -- доступ всем;
friendly(default) -- доступ внутри пакета (по умолчанию);
protected -- доступ в рамках ...
private -- доступ в рамках файла.

15. Чем отличается статический внутренний класс от просто внутреннего класса?
Статический внутренний класс имеет доступ только к static полям внешнего класса, просто внутренний даёт доступ ко всем полям. Доступ к non-static полям можно произвести через ссылку на объект внешнего класса внутри статического внутреннего.

16. Можно ли обратиться к не-статической переменной из статического метода?
Статический метод -- метод, относящийся не к объекту класса, а к самому классу (т.е. может быть использован без создания объектов этого класса).
Можно через ссылку на объект, содержащий эту нестатическую переменную.

17. Какие типы данных есть в Java?
Стандартные типы данных в java:
byte(8), short(16), int(32), long(64).
float(32 = 1 [знак] + 23 [мантисса] + 8 [степень]), double(64)
char(16)
boolean (true/false), void
Остальные классы непримитивные, наследуются от Object.
Для примитивных типов данных есть классы-оболочки Boolean, Character
Integer, Byte, Long, Short, Float, Double (наследованы от общего класса Number)

18. Чем отличаются переопределение (Override) и перегрузка (Overload)
Аннотация @Override используется при переопределении метода в классе-наследнике, например, или в классе, который реализует какой-то интерфейс, она сообщает компилятору о том, что мы именно переопределяем существующую фукнцию (с той же сигнатурой). 
Overload необходима, если мы хотим перегрузить метод (т.е. он имеет то же имя, но другую сигнатуру).

19. Что такое итератор?
Это параметризованный класс, который позволяет просматривать элементы коллекции. 
Имеет 3 основных функции:
boolean hasNext() -- возвращает true, если следующий элемент есть, false в противном случае.
T next() -- возвращение элемента, на котором сейчас находится итератор, сдвиг итератора.
remove() -- удаление элемента, на котором сейчас находится итератор

20. Перечислите основные категории исключительных ситуаций.
Исключительная ситуация это некоторое событие, приводящее к некорректной работе (фатальной ошибке) системы. В Java все исключительные ситуации делятся на 2 категории
- Error (ошибка компиляции)
- Exception (отлавливаемые пользователем исключения) - RuntimeExcepton (не отлавливаемые исключения, на этапе работы программы)
К отлавливаемым исключениям относятся следующие исключения:
не найден класс, ошибка потока ввода/вывода и др.
К не отлавливаемым относятся исключения: 
деление на ноль, выход за пределы коллекции и др.
Exception можно создать свой. Для этого надо либо наследоваться от класса Exception, либо реализовать интерфейс Throwable.

21. Какая разница между throw и throws?
throw ключевое слово, позволяющее "выбрасывать" исключения из некоторого места в методе:
throw new Exception("Exception");
Ключевое слово throws описывает, какие исключительные ситуации может генерировать (или пробрасывать дальше) метод. 
void method A() throws FileNotFoundException {...}
При наследовании существует два правило относительно исключений, которые может выбрасывать метод:
- конструктор Deriverd класса обязан выбрасывать исключения (или из подклассы), которые выбрасывает конструктор Parent класса (т.к. вызывается конструктор класса-родителя)
- при перегрузке метода, он не может выбрасывать исключения, которые не выбрасывает класс-родитель.

22. Зачем нужен блок finally?
В конструкции 
try { ... } catch (Exception e) { ... } finally { ... }
блок finally необходим, чтобы описать действия, которые должны быть _обязательно_ сделаны перед закрытием. Он необходим, например, для закрытия файлов ресурсов (если мы не описали их в try (...), т.е. не сделали autocloseable), для выполнения команды lock.unlock() (хоть она и не обязательна должна находиться там).

23. Что такое finalize?
Метод, который вызывается у объекта перед тем, как он будет удалён с помощью garabageCollector.
Он есть у класса Object, наследниками которого являются все классы. Может быть переопределён.

24. Перечислите все виды внутренних классов.
Локальные классы (описан выше)
Статические классы (описан выше)
Анонимные классы (необходимы для расширения / изменения свойств конкретного объекта некоторого класса, не имеют имени, не может быть определён конструктор)
class A { int foo() { return 1; } }
A a1 = new A() { int foo () { return 2; } };
A a2 = new A();
a1.foo(); // --> 2
a2.foo(); // --> 1
